{"version":3,"file":"static/js/61800.b116cf5f.chunk.js","mappings":"yZA0BA,QAAa,EAAe,GASrB,IAAMA,EAAoB,UAC/B,gBAAGC,EAAH,EAAGA,iBAAH,OAA0B,QAAzB,IAAD,6LAKI,KAMAA,IACF,QADkB,+HAUtBD,EAAkBE,aAAe,KAEjC,IAAMC,GAAkE,IAAAC,aACtE,WAA4DC,GAAgC,IAAzFC,EAAyF,EAAzFA,KAASC,GAAgF,YAC1F,GAA0C,SAA1C,eAAOC,EAAP,KAAsBC,EAAtB,KACA,GAAwC,IAAAC,UAAS,GAAjD,eAAOC,EAAP,KAAqBC,EAArB,KACMC,GAAiB,IAAAC,QAAO,GAExBC,GAAgB,OAAmBN,EAAkBJ,GAErDW,GAAkB,SAAS,SAACC,GAC5BA,EAAQ,GAAGC,YAAYC,MAAQN,EAAeO,SAChDR,GAAgB,SAAAS,GACd,OAAa,IAATA,EAAmBA,EAChBA,EAAO,OAGjB,KAEGC,EAAiB,IAAIC,eAAeP,GAEpCQ,EAAuB,IAAIC,sBAC/B,SAAAR,GACMA,EAAQ,GAAGS,kBAAoB,GAAKf,EAAeL,EAAKqB,OAAS,GAC/DV,EAAQ,GAAGW,aAAYf,EAAeO,QAAUH,EAAQ,GAAGW,WAAWT,MAAQ,GAClFP,GAAgB,SAAAS,GACd,OAAIA,IAASf,EAAKqB,OAAS,EAAUN,EAC9BA,EAAO,MAEPb,IAAeA,EAAcqB,MAAMC,WAAa,aAE7D,CAAEC,KAAMvB,EAAewB,UAAW,KAGpC,IAAAC,YAAU,WACR,GAAIzB,GAAiBA,EAAc0B,UAIjC,OAHAV,EAAqBW,QAAQ3B,EAAc0B,WAC3CZ,EAAea,QAAQ3B,GAEhB,WACLgB,EAAqBY,aACrBd,EAAec,gBAGlB,CAAC5B,EAAeG,IAEnB,IAAQ0B,GAAQ,SAARA,IAER,OACE,UAAC,KAAD,kBACM9B,GADN,IAEE+B,UAAW,CAAEC,IAAK,EAAGC,WAAY,UACjCC,GAAIzC,EACJC,iBAAkBU,IAAiBL,EAAKqB,OAAS,EACjDtB,IAAKU,EAAa,UAEjBJ,EAAe,IACd,iCACE,SAAC,IAAU,CACT+B,KAAK,QACLC,UAAQ,EACRC,QAAQ,OACRC,KAAK,yBACLC,KAAM,CAAEC,MAAOzC,EAAK0C,MAAM,EAAGrC,GAAcsC,iBAAW,IAExD,SAAC,KAAI,CAACC,KAAI,gBAAWb,SAAK,UAAI,GAGjC/B,EAAK0C,MAAMrC,GAAcwC,KAAI,SAACC,EAAOC,GACpC,IACIC,EADIC,EAA2CH,EAA3CG,GAAIC,EAAuCJ,EAAvCI,QAASC,EAA8BL,EAA9BK,OAAWC,GAAhC,OAAmDN,EAAnD,GAqBA,OAlBEE,EADEF,EAAMO,MAEN,UAAC,MAAD,gBAAeA,KAAMP,EAAMO,MAAUD,GAArC,IAAmD,UAChDD,EAAM,IAAGD,KADDD,GAINH,EAAMQ,SAEX,UAAC,KAAD,gBAAiBhB,QAAQ,QAAWc,GAApC,IAAkD,UAC/CD,EAAM,IAAGD,KADCD,IAMb,UAAC,KAAD,kBAAmBG,GAAnB,IAAiC,UAC9BD,EAAM,IAAGD,KADDD,GAKXF,IAAU/C,EAAK0C,MAAMrC,GAAcgB,OAAS,EAAU2B,GAGxD,UAAC,EAAAO,SAAQ,WACNP,GACD,SAAC,KAAI,CAACJ,KAAI,gBAAWb,SAAK,KAFbkB,cAKjB,MAMV,O,qIC1IaO,EAAiB,UAAiC,YAAgB,IAAb1C,EAAa,EAAbA,QAChE,OAAO,QAAP,2HAQKA,IACH,QADE,sDAOA2C,GAA4D,IAAA3D,aAChE,WAEEC,GACE,IAFA2D,EAEA,EAFAA,MAAOC,EAEP,EAFOA,aAAcC,EAErB,EAFqBA,SAAa3D,GAElC,YAOF,OACE,SAACuD,GAAD,kBACMvD,GADN,IAEEa,SAAS6C,IAAgBD,GAAQC,IAAiBD,EAClDG,KAAK,WACLC,SAVEH,GAAgBD,EACXC,IAAiBD,EAAQ,OAAIK,EAE/B,EAOkB,4BACHL,GACpBT,GAAE,UAAKS,EAAL,UACF3D,IAAKA,EAAG,SAEP6D,SAAQ,MAMjBH,EAAS7D,aA/CoC,CAC3C8D,MAAO,IAgDT,O,qSChCMM,EAAc,SAACC,GAAD,OAAmB,QAAlB,IAAD,sFAGIA,IA4GXC,GAAY,QAAOC,EAAA,EAAP,CAAH,2RAKlB,SAAAC,GAAK,MACa,eAAlBA,EAAMC,QA9GkB,SAAC,GAA8D,MAA5DC,EAA4D,EAA5DA,SAAUC,EAAkD,EAAlDA,MACjCC,EADmF,EAA3CC,SAE1CF,EAAMG,WAAWC,KAAKF,SAASG,WAC/BL,EAAMG,WAAWC,KAAKE,KAAKD,WACzBE,EAAc,WAAG,SAAS,kBAAM,QAAe,GAAKN,aAAtC,QAAwD,GACpEO,EAAYR,EAAMM,KAAlBE,QAER,OAAO,QAAP,k5BAIqBA,EACGA,EAIXT,EAAWE,EAAeD,EAAMM,KAAKG,QAAQ,oBAmBxCV,EAAWE,EAAeM,EAC7BR,EAAW,QAAU,OAU9BN,EAAYc,GAIZd,EAAYc,GACMP,EAAMM,KAAKI,OAAOC,MAGtC,IACkCH,GAuDHI,CAAoBf,GAlD/B,SAAC,GAAoD,MAAlDE,EAAkD,EAAlDA,SAAUC,EAAwC,EAAxCA,MAC/Ba,EAAcb,EAAMM,KAAKG,QAAQ,eACjCR,EAAeD,EAAMM,KAAKG,QAAQK,YAClCP,EAAc,WAAG,SAAS,kBAAM,QAAe,GAAKN,aAAtC,QAAwD,GACpEO,EAAYR,EAAMM,KAAlBE,QAER,OAAO,QAAP,grBAKWR,EAAMM,KAAKG,QAAQ,oBAEZI,EACKL,EAECA,EAGUK,EAMnBd,EAAW,QAAU,OAKlBE,EAIZR,EAAYc,GAIZd,EAAYQ,GACsBA,GAWwBc,CAAkBlB,MAChF,SAAAA,GAAK,OACLA,EAAME,WACN,QADA,yDAgBW,SAAAF,GAAK,OAAIA,EAAMG,MAAMM,KAAK,uBAIzCX,EAAUtE,aAAe,KAEzB,I,IAsBA,GAtByC,IAAAE,aACvC,WAEEC,GACE,IAFAuE,EAEA,EAFAA,SAAUG,EAEV,EAFUA,SAAUc,EAEpB,EAFoBA,QAASC,EAE7B,EAF6BA,MAAOC,EAEpC,EAFoCA,KAAMC,EAE1C,EAF0CA,SAAazF,GAEvD,YACF,OACE,UAACiE,GAAD,gBACEnE,IAAKA,EACLuE,SAAUA,EACVG,SAAUA,EACVJ,QAASoB,EACTC,SAAUA,EACVD,KAAK,UACDxF,GAPN,IAOe,WAEb,gCAAoBsF,EAAO,SAAGA,QAAO,GACpCC,UAAK,M,yDC3KDG,EAAa,UACxB,gBAAGF,EAAH,EAAGA,KAAMlB,EAAT,EAASA,MAAT,OAAqB,QAApB,OAAD,wEAEuB,eAATkB,EAAwB,OAAS,UAClC,eAATA,IACF,QADE,kGAEiClB,EAAMM,KAAKG,QAAQ,oBAM1DW,EAAW/F,aAAe,KAM1B,IA0GA,GA1G0D,IAAAE,aACxD,WASEC,GACE,IA6BE6F,EA7BF,IARAjB,KAAAA,OAQA,MARO,GAQP,MAPAc,KAAAA,OAOA,MAPO,aAOP,EANA9B,EAMA,EANAA,aACAkC,EAKA,EALAA,WAKA,IAJApB,SAAAA,OAIA,SAHGxE,GAGH,YAEI6F,GAAU,IAAAtF,QAAkD,IAG5DuF,EAAiB,SAAjBA,EAAkBC,EAAsBjD,GAAuB,MACnE,aAAI+C,EAAQhF,eAAZ,OAAI,EAAiBO,OAAQ,CAC3B,IAAQ4E,EAAQD,EAARC,IACR,GAAY,eAARA,GAAgC,cAARA,EAAqB,CAC/C,IAAMC,EAAYnD,EAAQ,EAAI4B,EAAKtD,OAAS0B,EAAQ,EAAI,EAClDoD,EAAUL,EAAQhF,QAAQoF,GAE5B,OAACC,QAAD,IAACA,GAAAA,EAAST,SAGZK,EAAeC,EAAOE,GAFf,OAAPC,QAAO,IAAPA,GAAAA,EAASjB,aAIN,GAAY,cAARe,GAA+B,YAARA,EAAmB,CACnD,IAAMG,EAAsB,IAAVrD,EAAc4B,EAAKtD,OAAS,EAAI0B,EAAQ,EACpDsD,EAAUP,EAAQhF,QAAQsF,GAC5B,OAACC,QAAD,IAACA,GAAAA,EAASX,SAGZK,EAAeC,EAAOI,GAFf,OAAPC,QAAO,IAAPA,GAAAA,EAASnB,WAejB,OALEU,EADEnB,EACa,WAEA,WAIf,SAAC6B,EAAA,GAAD,kBACMrG,GADN,IAEE+B,UAAW,CACTuE,UAAoB,eAATd,EAAwB,cAAW1B,GAEhDyC,KAAM,CAAEC,OAAQ,GAChBtE,GAAIwD,EACJ5F,IAAKA,EACL0F,KAAMA,EACN5B,KAAK,UAAS,SAEbc,EAAK9B,KAAI,SAAC6D,EAAcC,GACvB,IAAQtD,EAAoCqD,EAApCrD,KAAMT,EAA8B8D,EAA9B9D,KAAM4C,EAAwBkB,EAAxBlB,MAAOvC,EAAiByD,EAAjBzD,GAAIyC,EAAagB,EAAbhB,SACzBpB,EAAWrB,IAAOU,EAExB,OACE,SAAC,EAAG,CACFV,GAAIA,EAAE,gBACSqB,EAAQ,0BACLrB,EADK,UAEvBsC,QAAS3C,EACT4C,MACmB,kBAAVA,IACL,SAACoB,EAAA,EAAK,CAACtE,QAASgC,EAAW,cAAgBsB,EAAY,SAAGJ,QAAK,GAGnEnC,KAAMA,EACNoB,SAAUA,IAAY,EACtBH,SAAUA,EACVhB,QAAS,SAAC0C,GACE,OAAVH,QAAU,IAAVA,GAAAA,EAAa5C,EAAI+C,IAEnBnC,KAAK,MACL9D,IAAK,SAAC8G,GACJf,EAAQhF,QAAQ6F,GAAKE,GAEvBC,UAAW,SAACC,GACN,CAAC,aAAc,YAAa,YAAa,WAAWC,SAASD,EAAEd,MACjEc,EAAEE,kBAGNC,QAAS,SAACH,GACRhB,EAAegB,EAAGJ,IAGpBxE,GAAIkB,EAAO8D,EAAA,QAAOpD,EAClBD,SAAUQ,OAAWP,GAAa,EAAC,aACvBnB,EACZ6C,KAAMA,EACNC,SAAUA,GALLzC,aAQT,O,+uBCzHJmE,EAAiB,WACrBC,OAAOC,SAAS,EAAG,IAGfC,EAAA,WAmBJ,cAAkF,IAApEC,EAAoE,EAApEA,SAAoE,IAA1DC,gBAAAA,OAA0D,MAAxCJ,OAAwC,MAAhCK,OAAAA,OAAgC,MAAvB,EAAuB,kBAlBlF,8C,yDACA,qC,yDACA,mBACA,mBACA,mBACA,mBACA,mBACA,mBACA,mBACA,mBACA,mBACA,mBACA,mBACA,mBACA,mBACA,mBACA,mBAGEC,KAAKF,gBAAkBA,EACvBE,KAAKD,OAASA,EAEd,EAAAC,KAAI,EAAmB,IAAG,KAC1B,EAAAA,KAAI,EAAmB,IAAG,KAC1B,EAAAA,KAAI,EAAkBC,IAAG,KACzB,EAAAD,KAAI,EAAqBC,IAAG,KAC5B,EAAAD,KAAI,EAAiBC,IAAG,KACxB,EAAAD,KAAI,GAAgB,EAAK,KACzB,EAAAA,KAAI,EAAqBC,IAAG,KAC5B,EAAAD,KAAI,EAAqBC,IAAG,KAC5B,EAAAD,KAAI,GAAkB,cAAQ,KAC9B,EAAAA,KAAI,GAAkB,cAAQ,KAE9B,EAAAA,KAAI,EAAmBA,KAAKF,kBAAoBJ,OAAM,KAGtD,EAAAM,KAAI,EAAwBA,KAAKE,aAAY,KAG7C,EAAAF,KAAI,EAAyB,EAAC,KAG9B,EAAAA,KAAI,EAAoB,EAAC,KAEzB,EAAAA,KAAI,EAAaA,KAAKG,YAAYN,GAAS,KAC3CG,KAAKI,oBACLJ,KAAKK,c,0CAGP,SAAYR,GAcV,OAbA,EAAAG,KAAI,GACkB,kBAAbH,EACHS,MAAMC,KAAKC,SAASC,iBAA8BZ,IAClDA,GACJ3E,KAAI,SAAAwF,GAAO,MAAK,CAChBA,QAAAA,EACAC,SAAS,EACTC,IAAKX,IACLY,OAAQZ,IACRa,OAAQb,IACRc,iBAAkBd,QACjB,KAEI,EAAAD,KAAI,S,yBAGb,WACEA,KAAKgB,aACL,EAAAhB,KAAI,EAAkBA,KAAKiB,SAASC,KAAKlB,MAAK,KAC9C,EAAAA,KAAI,EAAkBA,KAAKmB,SAASD,KAAKlB,MAAK,KAC9CA,KAAKF,gBAAgBsB,iBAAiB,SAAU,EAAApB,KAAI,QACpDN,OAAO0B,iBAAiB,SAAU,EAAApB,KAAI,QAEtCN,OAAO0B,iBAAiB,eAAgB3B,K,wBAG1C,WACEO,KAAKF,gBAAgBuB,oBAAoB,SAAU,EAAArB,KAAI,QACvDN,OAAO2B,oBAAoB,SAAU,EAAArB,KAAI,QACzCN,OAAO2B,oBAAoB,eAAgB5B,K,+BAG7C,WACE,EAAAO,KAAI,OAAWsB,SAAQ,SAAAC,GACrB,IAAMC,EAAOD,EAAQb,QAAQe,wBAC7BF,EAAQX,IAAMY,EAAKZ,IACnBW,EAAQV,OAASW,EAAKX,OACtBU,EAAQT,OAASU,EAAKV,Y,sBAI1B,WAAQ,WACNY,aAAa,EAAA1B,KAAI,QAEjB,IAAM2B,EAAiB3B,KAAKE,aAE5B,EAAAF,KAAI,EAAkB4B,OAAOC,MAAM,EAAA7B,KAAI,QAEnC,EAAAA,KAAI,OADJ,EAAAA,KAAI,OACqB,KAG7B,EAAAA,KAAI,EAAoB2B,EAAiB,EAAA3B,KAAI,OAAiB,EAAI,GAAK,EAAC,KAGxE,EAAAA,KAAI,EAAyB2B,EAAiB,EAAA3B,KAAI,OAAqB,KAGvE,EAAAA,KAAI,EAAiB2B,EAAc,KAGnC,EAAA3B,KAAI,EAAqBN,OAAOoC,YAAW,WAEzC,IAAI,EAAwB,IAAI,OAAc,KAG9C,IAAI,EAAqB7B,IAAG,KAC5B,IAAI,EAAqBA,IAAG,KAE5B,IAAI,GAAgB,EAAK,OACxB,EAAAD,KAAI,QAAiB,KAGpB,EAAAA,KAAI,SAMR,EAAAA,KAAI,GAAgB,EAAI,KAGxBA,KAAKI,oBAML,EAAAJ,KAAI,EAAqBA,KAAK+B,oBAAmB,KACjD,EAAA/B,KAAI,EAAqBA,KAAKgC,uBAAsB,MAflDhC,KAAKiC,iB,sBAoBT,WAAQ,WACNP,aAAa,EAAA1B,KAAI,QACjB,EAAAA,KAAI,EAAkBN,OAAOoC,YAAW,WACtC,EAAK1B,oBACL,IAAI,OAAWkB,SAAQ,SAAAC,GACjBA,EAAQZ,SAAS,EAAKuB,SAASX,QAEpC,EAAAvB,KAAI,QAAiB,O,wBAG1B,WACE,OAAO,EAAAA,KAAI,OACNA,KAAKF,gBAA2BqC,QAChCnC,KAAKF,gBAAgCsC,Y,+BAG5C,WAEE,OAAKR,OAAOC,MAAM,EAAA7B,KAAI,QAIfqC,KAAKC,IAAI9B,SAAS+B,gBAAgBC,aAAc9C,OAAO+C,aAAe,GAHpE,EAAAzC,KAAI,S,kCAMf,WAEE,IAAK4B,OAAOC,MAAM,EAAA7B,KAAI,QACpB,OAAO,EAAAA,KAAI,OAGb,IAAM0C,EAAiB1C,KAAK+B,oBACxBY,EAAMD,EAMV,OAJK,EAAA1C,KAAI,SACP2C,EAAMD,EAAkB1C,KAAKF,gBAAgC2B,wBAAwBb,KAGhF+B,I,8BAGT,SAAiBpB,GACf,IAAMqB,EAAM5C,KAAK+B,oBACXY,EAAM3C,KAAKgC,uBAGjB,OAAOW,EAFK,EAAA3C,KAAI,QAEI4C,EAAMD,IAAQpB,EAAQV,OAASb,KAAKD,S,0BAG1D,WAAY,WAEV,IAA+B,IAA3B,EAAAC,KAAI,OAqBR,OAnBA,EAAAA,KAAI,OAAWsB,SAAQ,SAAAC,GACrB,IAAMsB,EAAiB,EAAKC,iBAAiBvB,GACvCwB,GACHnB,OAAOC,MAAMN,EAAQR,mBAAqBQ,EAAQT,SAAWS,EAAQR,iBAExE,GAAI8B,EACGtB,EAAQZ,UAAWoC,GACtBrD,OAAOsD,uBAAsB,kBAAM,EAAKd,SAASX,WAE9C,GAAIA,EAAQZ,SAAWoC,EAAiB,CAC7C,IAAME,EAAY,EAAK/C,aAAeqB,EAAQX,IAAM,EAAKb,OAEzDL,OAAOsD,uBAAsB,WAC3B,EAAKE,YAAY3B,GACjBA,EAAQb,QAAQ9G,MAAMqJ,UAAtB,UAAqCA,EAArC,aAKCjD,O,sBAGT,SAASuB,GAMP,OALAA,EAAQb,QAAQ9G,MAAMuJ,SAAW,SACjC5B,EAAQb,QAAQ9G,MAAMqJ,UAAY,GAClC1B,EAAQb,QAAQ9G,MAAMgH,IAAtB,UAA+BZ,KAAKoD,YAAY7B,GAAhD,MACAA,EAAQR,iBAAmBQ,EAAQT,OACnCS,EAAQZ,SAAU,EACXX,O,yBAGT,SAAYuB,GAKV,OAJAA,EAAQb,QAAQ9G,MAAMuJ,SAAW,GACjC5B,EAAQb,QAAQ9G,MAAMqJ,UAAY,GAClC1B,EAAQb,QAAQ9G,MAAMgH,IAAM,GAC5BW,EAAQZ,SAAU,EACXX,O,yBAGT,SAAYuB,GACV,IAAM8B,EAAWrD,KAAKgC,uBAClBjC,EAASC,KAAKD,OAMlB,OAJIwB,EAAQT,OAASd,KAAKD,OAASsD,IACjCtD,EAASsD,EAAW9B,EAAQT,OAASf,GAGhCA,I,qBAGT,WACEC,KAAKgB,aACL,EAAAhB,KAAI,OAAWsB,QAAQtB,KAAKkD,iB,EAzP1B,G,kNAiRN,IAfuB,SAACI,GACtB,IAAMC,GAAW,IAAA1K,WAEjB,IAAA2K,kBAAgB,WAKd,OAJA,OAAIF,QAAJ,IAAIA,GAAAA,EAASzD,WACX0D,EAASpK,QAAU,IAAIyG,EAAS0D,IAG3B,WAAK,MACV,UAAAC,EAASpK,eAAT,SAAkBsK,UAClBF,EAASpK,aAAUiD,KAEpB,CAACkH","sources":["../node_modules/@pega/cosmos-react-core/src/components/Breadcrumbs/Breadcrumbs.tsx","../node_modules/@pega/cosmos-react-core/src/components/Tabs/TabPanel.tsx","../node_modules/@pega/cosmos-react-core/src/components/Tabs/Tab.tsx","../node_modules/@pega/cosmos-react-core/src/components/Tabs/Tabs.tsx","../node_modules/@pega/cosmos-react-core/src/hooks/useScrollStick.ts"],"sourcesContent":["import {\n  forwardRef,\n  Fragment,\n  FunctionComponent,\n  PropsWithoutRef,\n  Ref,\n  useEffect,\n  useRef,\n  useState\n} from 'react';\nimport styled, { css } from 'styled-components';\n\nimport { useElement, useConsolidatedRef, useDirection } from '../../hooks';\nimport { defaultThemeProp } from '../../theme';\nimport { BaseProps, ForwardProps, NoChildrenProp } from '../../types';\nimport { debounce } from '../../utils';\nimport Button from '../Button';\nimport Flex from '../Flex';\nimport Link from '../Link';\nimport Icon, { StyledIcon, registerIcon } from '../Icon';\nimport * as caretLeftIcon from '../Icon/icons/caret-left.icon';\nimport * as caretRightIcon from '../Icon/icons/caret-right.icon';\nimport MenuButton from '../MenuButton';\nimport Text from '../Text';\nimport { MenuItemProps } from '../Menu';\n\nregisterIcon(caretLeftIcon, caretRightIcon);\n\nexport interface BreadcrumbsProps extends BaseProps, NoChildrenProp {\n  /** A set of actions representing the chronological hierarchy of pages or locations leading to the current view. */\n  path: MenuItemProps[];\n  /** Ref forwarded to the wrapping element. */\n  ref?: Ref<HTMLDivElement>;\n}\n\nexport const StyledBreadcrumbs = styled.div<{ oneItemRemaining: boolean }>(\n  ({ oneItemRemaining }) => css`\n    white-space: nowrap;\n    overflow: visible;\n    visibility: hidden;\n\n    ${StyledIcon} {\n      width: 1em;\n      height: 1em;\n      flex-shrink: 0;\n    }\n\n    ${oneItemRemaining &&\n    css`\n      & > :last-child {\n        text-overflow: ellipsis;\n        overflow: hidden;\n      }\n    `}\n  `\n);\n\nStyledBreadcrumbs.defaultProps = defaultThemeProp;\n\nconst Breadcrumbs: FunctionComponent<BreadcrumbsProps & ForwardProps> = forwardRef(\n  ({ path, ...restProps }: PropsWithoutRef<BreadcrumbsProps>, ref: BreadcrumbsProps['ref']) => {\n    const [breadcrumbsEl, setBreadcrumbsEl] = useElement<HTMLDivElement>();\n    const [numMenuItems, setNumMenuItems] = useState(0);\n    const minInlineWidth = useRef(0);\n\n    const breadcrumbRef = useConsolidatedRef(setBreadcrumbsEl, ref);\n\n    const debouncedResize = debounce((entries: ResizeObserverEntry[]) => {\n      if (entries[0].contentRect.width > minInlineWidth.current) {\n        setNumMenuItems(curr => {\n          if (curr === 0) return curr;\n          return curr - 1;\n        });\n      }\n    }, 100);\n\n    const resizeObserver = new ResizeObserver(debouncedResize);\n\n    const intersectionObserver = new IntersectionObserver(\n      entries => {\n        if (entries[0].intersectionRatio < 1 && numMenuItems < path.length - 1) {\n          if (entries[0].rootBounds) minInlineWidth.current = entries[0].rootBounds.width + 1;\n          setNumMenuItems(curr => {\n            if (curr === path.length - 1) return curr;\n            return curr + 1;\n          });\n        } else if (breadcrumbsEl) breadcrumbsEl.style.visibility = 'visible';\n      },\n      { root: breadcrumbsEl, threshold: 1 }\n    );\n\n    useEffect(() => {\n      if (breadcrumbsEl && breadcrumbsEl.lastChild) {\n        intersectionObserver.observe(breadcrumbsEl.lastChild as Element);\n        resizeObserver.observe(breadcrumbsEl);\n\n        return () => {\n          intersectionObserver.disconnect();\n          resizeObserver.disconnect();\n        };\n      }\n    }, [breadcrumbsEl, numMenuItems]);\n\n    const { end } = useDirection();\n\n    return (\n      <Flex\n        {...restProps}\n        container={{ gap: 1, alignItems: 'center' }}\n        as={StyledBreadcrumbs}\n        oneItemRemaining={numMenuItems === path.length - 1}\n        ref={breadcrumbRef}\n      >\n        {numMenuItems > 0 && (\n          <>\n            <MenuButton\n              text='Links'\n              iconOnly\n              variant='link'\n              icon='folder-hierarchy-solid'\n              menu={{ items: path.slice(0, numMenuItems).reverse() }}\n            />\n            <Icon name={`caret-${end}`} />\n          </>\n        )}\n        {path.slice(numMenuItems).map((crumb, index) => {\n          const { id, primary, visual, ...restCrumbProps } = crumb;\n          let Comp;\n          if (crumb.href)\n            Comp = (\n              <Link key={id} href={crumb.href} {...restCrumbProps}>\n                {visual} {primary}\n              </Link>\n            );\n          else if (crumb.onClick)\n            Comp = (\n              <Button key={id} variant='link' {...restCrumbProps}>\n                {visual} {primary}\n              </Button>\n            );\n          else\n            Comp = (\n              <Text key={id} {...restCrumbProps}>\n                {visual} {primary}\n              </Text>\n            );\n\n          if (index === path.slice(numMenuItems).length - 1) return Comp;\n\n          return (\n            <Fragment key={id}>\n              {Comp}\n              <Icon name={`caret-${end}`} />\n            </Fragment>\n          );\n        })}\n      </Flex>\n    );\n  }\n);\n\nexport default Breadcrumbs;\n","import { forwardRef, FunctionComponent, ReactNode, Ref, PropsWithoutRef } from 'react';\nimport styled, { css } from 'styled-components';\n\nimport { ForwardProps } from '../../types';\n\ninterface TabPanelProps {\n  /** The id of the Tab that the tab panel is related to. */\n  tabId: string;\n  /**\n   * The current selected value of the tabs. Controls the visibility of the tab panel.\n   * The tabsValue must match the tabId in order for the TabPanel to show itself.\n   * */\n  currentTabId?: string;\n  /** Content of the tab panel. */\n  children: ReactNode;\n  /** Ref for the wrapping element. */\n  ref?: Ref<HTMLDivElement>;\n}\n\nconst defaultProps: Partial<TabPanelProps> = {\n  tabId: ''\n};\n\nexport const StyledTabPanel = styled.div<{ current: boolean }>(({ current }) => {\n  return css`\n    min-width: 0;\n    max-width: 100%;\n\n    :focus {\n      outline: none;\n    }\n\n    ${!current &&\n    css`\n      display: none;\n    `}\n  `;\n});\n\nconst TabPanel: FunctionComponent<TabPanelProps & ForwardProps> = forwardRef(\n  (\n    { tabId, currentTabId, children, ...restProps }: PropsWithoutRef<TabPanelProps>,\n    ref: TabPanelProps['ref']\n  ) => {\n    const getTabIndex = () => {\n      if (currentTabId && tabId) {\n        return currentTabId === tabId ? 0 : undefined;\n      }\n      return 0;\n    };\n    return (\n      <StyledTabPanel\n        {...restProps}\n        current={currentTabId && tabId ? currentTabId === tabId : true}\n        role='tabpanel'\n        tabIndex={getTabIndex()}\n        aria-labelledby={`${tabId}`}\n        id={`${tabId}-panel`}\n        ref={ref}\n      >\n        {children}\n      </StyledTabPanel>\n    );\n  }\n);\n\nTabPanel.defaultProps = defaultProps;\n\nexport default TabPanel;\n","import { FC, ReactNode, forwardRef, PropsWithoutRef, Ref } from 'react';\nimport styled, { StyledProps, css } from 'styled-components';\nimport { transparentize } from 'polished';\n\nimport { defaultThemeProp } from '../../theme';\nimport { tryCatch } from '../../utils/utils';\nimport { StyledCount } from '../Badges/Count';\nimport { ForwardProps } from '../../types';\nimport BareButton from '../Button/BareButton';\n\nimport { TabsProps } from './Tabs.types';\n\ninterface TabProps {\n  /** Indicates if this Tab is active. */\n  selected: boolean;\n  /**\n   * Indicates if the styling of this Tab is inverted.\n   * @deprecated\n   */\n  inverted: boolean;\n  /** The text to display as the name of the Tab. */\n  content: string;\n  /** A number to associate with the Tab. */\n  count?: ReactNode;\n  /** Determines the direction in which the Tab will render. */\n  type: TabsProps['type'];\n  /** Disables the tab if true */\n  disabled?: boolean;\n}\n\nexport interface StyledTabProps {\n  selected: TabProps['selected'];\n  inverted: TabProps['inverted'];\n  tabType: TabProps['type'];\n}\n\nconst activeStyle = (color: string) => css`\n  ::after {\n    display: block;\n    background-color: ${color};\n  }\n`;\n\nconst getHorizontalStyles = ({ selected, theme, inverted }: StyledProps<StyledTabProps>) => {\n  const primaryColor = inverted\n    ? theme.components.tabs.inverted.foreground\n    : theme.components.tabs.base.foreground;\n  const lightenedColor = tryCatch(() => transparentize(0.3, primaryColor)) ?? '';\n  const { spacing } = theme.base;\n\n  return css`\n    align-items: center;\n    display: flex;\n    flex-direction: row;\n    height: calc(4 * ${spacing});\n    padding: 0 calc(2 * ${spacing});\n    border: none;\n\n    span:first-of-type {\n      color: ${selected ? primaryColor : theme.base.palette['foreground-color']};\n      text-transform: uppercase;\n      display: inline-block;\n\n      ::before {\n        content: attr(data-content);\n        display: block;\n        font-weight: bold;\n        height: 0;\n        overflow: hidden;\n        visibility: hidden;\n      }\n    }\n\n    &:first-child {\n      margin-left: 0;\n    }\n\n    ::after {\n      background: ${selected ? primaryColor : lightenedColor};\n      display: ${selected ? 'block' : 'none'};\n      content: '';\n      position: absolute;\n      height: 0.125rem;\n      bottom: 0;\n      left: 0;\n      right: 0;\n    }\n\n    &:hover&:not(:disabled) {\n      ${activeStyle(lightenedColor)}\n    }\n\n    &:focus {\n      ${activeStyle(lightenedColor)}\n      box-shadow: inset ${theme.base.shadow.focus}\n    }\n\n    ${StyledCount} {\n      margin-inline-start: calc(0.5 * ${spacing});\n    }\n  `;\n};\n\nconst getVerticalStyles = ({ selected, theme }: StyledProps<StyledTabProps>) => {\n  const borderColor = theme.base.palette['border-line'];\n  const primaryColor = theme.base.palette.interactive;\n  const lightenedColor = tryCatch(() => transparentize(0.5, primaryColor)) ?? '';\n  const { spacing } = theme.base;\n\n  return css`\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    border-style: solid;\n    color: ${theme.base.palette['foreground-color']};\n    border-width: 0.0625rem 0;\n    border-color: ${borderColor};\n    height: calc(5.5 * ${spacing});\n    margin-top: -0.0625rem;\n    padding: 0 calc(2 * ${spacing});\n\n    &:first-child {\n      border-top: 0.0625rem solid ${borderColor};\n    }\n\n    ::after {\n      content: '';\n      position: absolute;\n      display: ${selected ? 'block' : 'none'};\n      top: 0;\n      bottom: 0;\n      right: 0;\n      width: 0.25rem;\n      background: ${primaryColor};\n    }\n\n    &:hover&:not(:disabled) {\n      ${activeStyle(lightenedColor)}\n    }\n\n    &:focus {\n      ${activeStyle(primaryColor)}\n      box-shadow: inset 0 0 0 0.0625rem ${primaryColor};\n    }\n  `;\n};\n\nexport const StyledTab = styled(BareButton)<StyledTabProps>`\n  position: relative;\n  background: none;\n  cursor: pointer;\n\n  ${props =>\n    props.tabType === 'horizontal' ? getHorizontalStyles(props) : getVerticalStyles(props)}\n  ${props =>\n    props.selected &&\n    css`\n      font-weight: bold;\n    `}\n  white-space: nowrap;\n\n  & + & {\n    margin-inline-start: 0;\n  }\n\n  &:focus {\n    outline: none;\n  }\n\n  &:disabled {\n    cursor: not-allowed;\n    opacity: ${props => props.theme.base['disabled-opacity']};\n  }\n`;\n\nStyledTab.defaultProps = defaultThemeProp;\n\nconst Tab: FC<TabProps & ForwardProps> = forwardRef(\n  (\n    { selected, inverted, content, count, type, disabled, ...restProps }: PropsWithoutRef<TabProps>,\n    ref: Ref<HTMLButtonElement>\n  ) => {\n    return (\n      <StyledTab\n        ref={ref}\n        selected={selected}\n        inverted={inverted}\n        tabType={type}\n        disabled={disabled}\n        type='button'\n        {...restProps}\n      >\n        <span data-content={content}>{content}</span>\n        {count}\n      </StyledTab>\n    );\n  }\n);\n\nexport default Tab;\n","import {\n  FunctionComponent,\n  MouseEvent,\n  KeyboardEvent,\n  forwardRef,\n  PropsWithoutRef,\n  Ref,\n  useRef\n} from 'react';\nimport styled, { css } from 'styled-components';\n\nimport { defaultThemeProp } from '../../theme';\nimport Flex from '../Flex';\nimport Link from '../Link';\nimport Count from '../Badges/Count';\nimport { ForwardProps } from '../../types';\n\nimport Tab from './Tab';\nimport { TabsProps } from './Tabs.types';\n\ntype TabItem = TabsProps['tabs'][number];\n\nexport const StyledTabs = styled.div<Partial<TabsProps>>(\n  ({ type, theme }) => css`\n    position: relative;\n    overflow: ${type === 'horizontal' ? 'auto' : 'visible'};\n    ${type === 'horizontal' &&\n    css`\n      border-bottom: 0.0625rem solid ${theme.base.palette['border-line']};\n      height: max-content;\n    `}\n  `\n);\n\nStyledTabs.defaultProps = defaultThemeProp;\n\n/**\n * The tabs component will take a list of tab data objects and render out a list of tabs in either vertical or horizontal direction.\n * The tabs component handles which tab is active but will give you a callback function that allows you to make changes when a new tab is activated\n */\nconst Tabs: FunctionComponent<TabsProps & ForwardProps> = forwardRef(\n  (\n    {\n      tabs = [],\n      type = 'horizontal',\n      currentTabId,\n      onTabClick,\n      inverted = false,\n      ...restProps\n    }: PropsWithoutRef<TabsProps>,\n    ref: Ref<HTMLElement>\n  ) => {\n    // Used to keep a reference for every tab in order to focus them with key presses\n    const tabRefs = useRef<(HTMLButtonElement | HTMLAnchorElement)[]>([]);\n\n    // Handles arrow keypresses for changing the focus\n    const changeTabFocus = (event: KeyboardEvent, index: number): void => {\n      if (tabRefs.current?.length) {\n        const { key } = event;\n        if (key === 'ArrowRight' || key === 'ArrowDown') {\n          const nextIndex = index + 1 < tabs.length ? index + 1 : 0;\n          const nextTab = tabRefs.current[nextIndex] as HTMLButtonElement;\n\n          if (!nextTab?.disabled) {\n            nextTab?.focus();\n          } else {\n            changeTabFocus(event, nextIndex);\n          }\n        } else if (key === 'ArrowLeft' || key === 'ArrowUp') {\n          const prevIndex = index === 0 ? tabs.length - 1 : index - 1;\n          const prevTab = tabRefs.current[prevIndex] as HTMLButtonElement;\n          if (!prevTab?.disabled) {\n            prevTab?.focus();\n          } else {\n            changeTabFocus(event, prevIndex);\n          }\n        }\n      }\n    };\n\n    let badgeVariant: 'inverted' | 'default';\n    if (inverted) {\n      badgeVariant = 'inverted';\n    } else {\n      badgeVariant = 'default';\n    }\n\n    return (\n      <Flex\n        {...restProps}\n        container={{\n          direction: type !== 'horizontal' ? 'column' : undefined\n        }}\n        item={{ shrink: 0 }}\n        as={StyledTabs}\n        ref={ref}\n        type={type}\n        role='tablist'\n      >\n        {tabs.map((tab: TabItem, i) => {\n          const { href, name, count, id, disabled } = tab;\n          const selected = id === currentTabId;\n\n          return (\n            <Tab\n              id={id}\n              aria-selected={selected}\n              aria-controls={`${id}-panel`}\n              content={name}\n              count={\n                typeof count === 'number' && (\n                  <Count variant={selected ? 'interactive' : badgeVariant}>{count}</Count>\n                )\n              }\n              href={href}\n              inverted={inverted || false}\n              selected={selected}\n              onClick={(event: MouseEvent<HTMLButtonElement | HTMLAnchorElement>) => {\n                onTabClick?.(id, event);\n              }}\n              role='tab'\n              ref={(el: HTMLButtonElement | HTMLAnchorElement) => {\n                tabRefs.current[i] = el;\n              }}\n              onKeyDown={(e: KeyboardEvent) => {\n                if (['ArrowRight', 'ArrowDown', 'ArrowLeft', 'ArrowUp'].includes(e.key)) {\n                  e.preventDefault();\n                }\n              }}\n              onKeyUp={(e: KeyboardEvent<any>) => {\n                changeTabFocus(e, i);\n              }}\n              key={id}\n              as={href ? Link : undefined}\n              tabIndex={selected ? undefined : -1}\n              aria-label={name}\n              type={type}\n              disabled={disabled}\n            />\n          );\n        })}\n      </Flex>\n    );\n  }\n);\n\nexport default Tabs;\n","import { useRef, useLayoutEffect } from 'react';\n\nexport interface ScrollStickOptions {\n  elements: string | HTMLElement[];\n  scrollContainer?: Stickers['scrollContainer'];\n  offset?: number;\n}\n\ninterface Sticker {\n  element: HTMLElement;\n  top: number;\n  bottom: number;\n  height: number;\n  isStuck: boolean;\n  priorStickHeight: number;\n}\n\ntype ElementsOption = string | HTMLElement[];\n\nconst onBeforeunload = () => {\n  window.scrollTo(0, 0);\n};\n\nclass Stickers {\n  scrollContainer: HTMLElement | Window;\n  offset: number;\n  #scrollDebounce: number;\n  #resizeDebounce: number;\n  #isWindowScroll: boolean;\n  #scrollIntervalStart: number;\n  #scrollIntervalChange: number;\n  #scrollDirection: number;\n  #priorScrollY: number;\n  #resizeTimeout: number;\n  #scrollEndTimeout: number;\n  #isScrolling: boolean;\n  #vpHeightSnapshot: number;\n  #sfHeightSnapshot: number;\n  #stickers: Sticker[];\n  #scrollHandler: () => void;\n  #resizeHandler: () => void;\n\n  constructor({ elements, scrollContainer = window, offset = 0 }: ScrollStickOptions) {\n    this.scrollContainer = scrollContainer;\n    this.offset = offset;\n\n    this.#scrollDebounce = 100;\n    this.#resizeDebounce = 300;\n    this.#resizeTimeout = NaN;\n    this.#scrollEndTimeout = NaN;\n    this.#priorScrollY = NaN;\n    this.#isScrolling = false;\n    this.#vpHeightSnapshot = NaN;\n    this.#sfHeightSnapshot = NaN;\n    this.#scrollHandler = () => {};\n    this.#resizeHandler = () => {};\n\n    this.#isWindowScroll = this.scrollContainer === window;\n\n    // Only gets reset after scroll stop timeout fires\n    this.#scrollIntervalStart = this.getScrollY();\n\n    // Used to determine scroll change within debounced scroll handler\n    this.#scrollIntervalChange = 0;\n\n    // Used to determine scroll direction by +1(page down) -1(page up)\n    this.#scrollDirection = 0;\n\n    this.#stickers = this.setStickers(elements);\n    this.snapshotItemRects();\n    this.addHandlers();\n  }\n\n  setStickers(elements: ElementsOption) {\n    this.#stickers = (\n      typeof elements === 'string'\n        ? Array.from(document.querySelectorAll<HTMLElement>(elements))\n        : elements\n    ).map(element => ({\n      element,\n      isStuck: false,\n      top: NaN,\n      bottom: NaN,\n      height: NaN,\n      priorStickHeight: NaN\n    }));\n\n    return this.#stickers;\n  }\n\n  addHandlers() {\n    this.rmHandlers();\n    this.#scrollHandler = this.onScroll.bind(this);\n    this.#resizeHandler = this.onResize.bind(this);\n    this.scrollContainer.addEventListener('scroll', this.#scrollHandler);\n    window.addEventListener('resize', this.#resizeHandler);\n    // Not sure we need this. Maybe when DOM was persisted...\n    window.addEventListener('beforeunload', onBeforeunload);\n  }\n\n  rmHandlers() {\n    this.scrollContainer.removeEventListener('scroll', this.#scrollHandler);\n    window.removeEventListener('resize', this.#resizeHandler);\n    window.removeEventListener('beforeunload', onBeforeunload);\n  }\n\n  snapshotItemRects() {\n    this.#stickers.forEach(sticker => {\n      const rect = sticker.element.getBoundingClientRect();\n      sticker.top = rect.top;\n      sticker.bottom = rect.bottom;\n      sticker.height = rect.height;\n    });\n  }\n\n  onScroll() {\n    clearTimeout(this.#scrollEndTimeout);\n\n    const currentScrollY = this.getScrollY();\n\n    this.#priorScrollY = !Number.isNaN(this.#priorScrollY)\n      ? this.#priorScrollY\n      : this.#scrollIntervalStart;\n\n    // Diff between priorScrollY and new currentScrollY to determine direction\n    this.#scrollDirection = currentScrollY - this.#priorScrollY > 0 ? 1 : -1;\n\n    // How much scroll changed + or - within the debounce interval\n    this.#scrollIntervalChange = currentScrollY - this.#scrollIntervalStart;\n\n    // Update old to new for next scroll event\n    this.#priorScrollY = currentScrollY;\n\n    // When scrolling has stopped\n    this.#scrollEndTimeout = window.setTimeout(() => {\n      // Reset for next scroll starting point\n      this.#scrollIntervalStart = this.#priorScrollY;\n\n      // Reset until next scroll\n      this.#vpHeightSnapshot = NaN;\n      this.#sfHeightSnapshot = NaN;\n\n      this.#isScrolling = false;\n    }, this.#scrollDebounce);\n\n    // Additional scroll calls always have to test for stick state change\n    if (this.#isScrolling) {\n      this.testForStick();\n      return;\n    }\n\n    // Only reaches here on first call and we note as in a scrolling state\n    this.#isScrolling = true;\n\n    // grab the current rect points for stickers to test against while scrolling\n    this.snapshotItemRects();\n\n    /**\n     * Get once and cache until scroll settles\n     * Unlikely to change and avoids additional reflows on scroll\n     */\n    this.#vpHeightSnapshot = this.getViewportHeight();\n    this.#sfHeightSnapshot = this.getScrollFrameHeight();\n\n    this.testForStick();\n  }\n\n  onResize() {\n    clearTimeout(this.#resizeTimeout);\n    this.#resizeTimeout = window.setTimeout(() => {\n      this.snapshotItemRects();\n      this.#stickers.forEach(sticker => {\n        if (sticker.isStuck) this.addStick(sticker);\n      });\n    }, this.#resizeDebounce);\n  }\n\n  getScrollY() {\n    return this.#isWindowScroll\n      ? (this.scrollContainer as Window).scrollY\n      : (this.scrollContainer as HTMLElement).scrollTop;\n  }\n\n  getViewportHeight() {\n    // If we have a height snapshot use it since this has likely been called on scroll\n    if (!Number.isNaN(this.#vpHeightSnapshot)) {\n      return this.#vpHeightSnapshot;\n    }\n\n    return Math.max(document.documentElement.clientHeight, window.innerHeight || 0);\n  }\n\n  getScrollFrameHeight() {\n    // If we have a height snapshot use it since this has likely been called on scroll\n    if (!Number.isNaN(this.#sfHeightSnapshot)) {\n      return this.#sfHeightSnapshot;\n    }\n\n    const viewportHeight = this.getViewportHeight();\n    let sfh = viewportHeight;\n\n    if (!this.#isWindowScroll) {\n      sfh = viewportHeight - (this.scrollContainer as HTMLElement).getBoundingClientRect().top;\n    }\n\n    return sfh;\n  }\n\n  testBottomInView(sticker: Sticker) {\n    const vph = this.getViewportHeight();\n    const sfh = this.getScrollFrameHeight();\n    const sic = this.#scrollIntervalChange;\n\n    return sfh + sic + (vph - sfh) >= sticker.bottom + this.offset;\n  }\n\n  testForStick() {\n    // Don't do anything if scrolling up\n    if (this.#scrollDirection === -1) return;\n\n    this.#stickers.forEach(sticker => {\n      const bottomIsInView = this.testBottomInView(sticker);\n      const hasHeightChange =\n        !Number.isNaN(sticker.priorStickHeight) && sticker.height !== sticker.priorStickHeight;\n\n      if (bottomIsInView) {\n        if (!sticker.isStuck || hasHeightChange) {\n          window.requestAnimationFrame(() => this.addStick(sticker));\n        }\n      } else if (sticker.isStuck && hasHeightChange) {\n        const marginTop = this.getScrollY() + sticker.top - this.offset;\n\n        window.requestAnimationFrame(() => {\n          this.removeStick(sticker);\n          sticker.element.style.marginTop = `${marginTop}px`;\n        });\n      }\n    });\n\n    return this;\n  }\n\n  addStick(sticker: Sticker) {\n    sticker.element.style.position = 'sticky';\n    sticker.element.style.marginTop = '';\n    sticker.element.style.top = `${this.getStickTop(sticker)}px`;\n    sticker.priorStickHeight = sticker.height;\n    sticker.isStuck = true;\n    return this;\n  }\n\n  removeStick(sticker: Sticker) {\n    sticker.element.style.position = '';\n    sticker.element.style.marginTop = '';\n    sticker.element.style.top = '';\n    sticker.isStuck = false;\n    return this;\n  }\n\n  getStickTop(sticker: Sticker) {\n    const spHeight = this.getScrollFrameHeight();\n    let offset = this.offset;\n\n    if (sticker.height + this.offset > spHeight) {\n      offset = spHeight - sticker.height - offset;\n    }\n\n    return offset;\n  }\n\n  cleanup() {\n    this.rmHandlers();\n    this.#stickers.forEach(this.removeStick);\n  }\n}\n\n/**\n * @example useScrollStick({ elements: [myColumnElements] | '.my-columns', offset: 20 });\n * @param options An object to set the sticky elements, the scroll container and an stuck offset in pixels.\n * @returns void.\n */\nconst useScrollStick = (options?: ScrollStickOptions): void => {\n  const instance = useRef<Stickers>();\n\n  useLayoutEffect(() => {\n    if (options?.elements) {\n      instance.current = new Stickers(options);\n    }\n\n    return () => {\n      instance.current?.cleanup();\n      instance.current = undefined;\n    };\n  }, [options]);\n};\n\nexport default useScrollStick;\n"],"names":["StyledBreadcrumbs","oneItemRemaining","defaultProps","Breadcrumbs","forwardRef","ref","path","restProps","breadcrumbsEl","setBreadcrumbsEl","useState","numMenuItems","setNumMenuItems","minInlineWidth","useRef","breadcrumbRef","debouncedResize","entries","contentRect","width","current","curr","resizeObserver","ResizeObserver","intersectionObserver","IntersectionObserver","intersectionRatio","length","rootBounds","style","visibility","root","threshold","useEffect","lastChild","observe","disconnect","end","container","gap","alignItems","as","text","iconOnly","variant","icon","menu","items","slice","reverse","name","map","crumb","index","Comp","id","primary","visual","restCrumbProps","href","onClick","Fragment","StyledTabPanel","TabPanel","tabId","currentTabId","children","role","tabIndex","undefined","activeStyle","color","StyledTab","BareButton","props","tabType","selected","theme","primaryColor","inverted","components","tabs","foreground","base","lightenedColor","spacing","palette","shadow","focus","getHorizontalStyles","borderColor","interactive","getVerticalStyles","content","count","type","disabled","StyledTabs","badgeVariant","onTabClick","tabRefs","changeTabFocus","event","key","nextIndex","nextTab","prevIndex","prevTab","Flex","direction","item","shrink","tab","i","Count","el","onKeyDown","e","includes","preventDefault","onKeyUp","Link","onBeforeunload","window","scrollTo","Stickers","elements","scrollContainer","offset","this","NaN","getScrollY","setStickers","snapshotItemRects","addHandlers","Array","from","document","querySelectorAll","element","isStuck","top","bottom","height","priorStickHeight","rmHandlers","onScroll","bind","onResize","addEventListener","removeEventListener","forEach","sticker","rect","getBoundingClientRect","clearTimeout","currentScrollY","Number","isNaN","setTimeout","getViewportHeight","getScrollFrameHeight","testForStick","addStick","scrollY","scrollTop","Math","max","documentElement","clientHeight","innerHeight","viewportHeight","sfh","vph","bottomIsInView","testBottomInView","hasHeightChange","requestAnimationFrame","marginTop","removeStick","position","getStickTop","spHeight","options","instance","useLayoutEffect","cleanup"],"sourceRoot":""}