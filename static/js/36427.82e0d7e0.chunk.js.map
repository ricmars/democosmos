{"version":3,"file":"static/js/36427.82e0d7e0.chunk.js","mappings":"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","sources":["../node_modules/@pega/cosmos-react-core/src/hooks/useAutoResize.ts","../node_modules/@pega/cosmos-react-core/src/components/TextArea/TextArea.styles.ts","../node_modules/@pega/cosmos-react-core/src/components/TextArea/TextArea.tsx","fields/TextArea.tsx"],"sourcesContent":["import { useRef, useState, MutableRefObject } from 'react';\n\nimport { debounce } from '../utils';\n\n/**\n * @example const [ref, resizeFunction] = useAutoResize();\n * maxHeight should be provided in pixels without units\n * minHeight should be provided in pixels without units\n * @returns * ref:: A reference for the element that the resize functionality should be applied to. [React RefObject](https://reactjs.org/docs/refs-and-the-dom.html)\n *          * resizeFunction:: The function to call to automatically resize the element.\n * element refers to auto resizable element\n */\nconst useAutoResize = <T extends HTMLElement = HTMLElement>(\n  maxHeight?: number,\n  minHeightProp?: number\n): [MutableRefObject<T | null>, () => void] => {\n  const element = useRef<T | null>(null);\n  const [minHeight, setMinHeight] = useState(minHeightProp || 0);\n\n  const autoResize = () => {\n    let scrollHeightElement: HTMLElement = element.current as HTMLElement;\n    let iframe: HTMLIFrameElement | undefined;\n    if (element.current && element.current instanceof HTMLIFrameElement) {\n      iframe = element.current;\n      scrollHeightElement =\n        element.current.contentDocument?.querySelector('body') ?? element.current;\n    }\n    if (element.current) {\n      let newMinHeight = minHeight;\n      if (!minHeight) {\n        newMinHeight = scrollHeightElement.scrollHeight;\n        setMinHeight(newMinHeight);\n      }\n      // Reset the heights to the base height so there is an overflow / or none to calculate the new height\n      scrollHeightElement.style.height = `${newMinHeight}px`;\n\n      if (maxHeight) {\n        scrollHeightElement.style.overflowY =\n          scrollHeightElement.scrollHeight > maxHeight ? 'auto' : 'hidden';\n        const height = `${Math.min(scrollHeightElement.scrollHeight, maxHeight)}px`;\n        scrollHeightElement.style.height = height;\n        if (iframe) iframe.style.height = height;\n      } else {\n        scrollHeightElement.style.height = `${scrollHeightElement.scrollHeight}px`;\n        if (iframe) iframe.style.height = `${scrollHeightElement.scrollHeight}px`;\n      }\n    }\n  };\n\n  const debouncedAutoResize = debounce(autoResize, 100);\n\n  return [element, debouncedAutoResize];\n};\n\nexport default useAutoResize;\n","import styled, { css } from 'styled-components';\n\nimport { defaultThemeProp } from '../../theme';\n\nconst StyledTextArea = styled.textarea<{ resizable: boolean }>(({ resizable }) => {\n  return css`\n    width: 100%;\n    min-height: ${props => props.theme.components['text-area']['min-height']};\n    padding: ${props => props.theme.components['text-area'].padding};\n    ${!resizable &&\n    css`\n      resize: none;\n    `}\n  `;\n});\n\nStyledTextArea.defaultProps = defaultThemeProp;\n\nexport default StyledTextArea;\n","import {\n  FC,\n  Ref,\n  forwardRef,\n  PropsWithoutRef,\n  ChangeEvent,\n  useCallback,\n  useState,\n  ChangeEventHandler,\n  useEffect\n} from 'react';\n\nimport { ForwardProps, NoChildrenProp } from '../../types';\nimport FormField from '../FormField';\nimport { FormControlProps, StyledFormControl } from '../FormControl';\nimport { hasProp } from '../../utils';\nimport { useAutoResize, useConsolidatedRef, useI18n, useUID } from '../../hooks';\nimport Text from '../Text';\n\nimport StyledTextArea from './TextArea.styles';\n\nexport interface TextAreaProps extends FormControlProps, NoChildrenProp {\n  /** Minimum length of characters that can be input. */\n  minLength?: number;\n  /** Maximum length of characters that can be input. */\n  maxLength?: number;\n  /**\n   * Allows the user to resize the Text Area.\n   * @default false\n   */\n  resizable?: boolean;\n  /**\n   * Enables the Text Area to resize itself automatically.\n   * @default false\n   */\n  autoResize?: boolean;\n  /**\n   * Display a live character count in relation to the maxLength.\n   * @default false\n   */\n  displayCharCount?: boolean;\n  /**\n   * Allow or disallow a value beyond the maxLength.\n   * @default true\n   */\n  hardStop?: boolean;\n  onChange?: ChangeEventHandler<HTMLTextAreaElement>;\n}\n\nconst TextArea: FC<TextAreaProps & ForwardProps> = forwardRef(\n  (props: PropsWithoutRef<TextAreaProps>, ref: Ref<HTMLTextAreaElement>) => {\n    const uid = useUID();\n    const {\n      id = uid,\n      value,\n      defaultValue,\n      required = false,\n      disabled = false,\n      label,\n      labelHidden,\n      info,\n      status,\n      resizable = false,\n      autoResize = false,\n      maxLength,\n      displayCharCount = false,\n      hardStop = true,\n      onChange: onChangeProp,\n      ...restProps\n    } = props;\n\n    const t = useI18n();\n\n    const [textAreaRef, resizeTextArea] = useAutoResize<HTMLTextAreaElement>(undefined, 100);\n    const consolidatedRef = useConsolidatedRef(textAreaRef, ref);\n    const [charCount, setCharCount] = useState(0);\n\n    const controlProp: {\n      value?: string;\n      defaultValue?: string;\n    } = {};\n\n    useEffect(() => {\n      if (hasProp(props, 'value')) {\n        setCharCount(props.value ? props.value.length : 0);\n      } else if (hasProp(props, 'defaultValue')) {\n        setCharCount(props.defaultValue ? props.defaultValue.length : 0);\n      }\n    }, [props]);\n\n    // Conditionally render component as controlled/uncontrolled\n    if (hasProp(props, 'value')) {\n      controlProp.value = value ?? '';\n    } else if (hasProp(props, 'defaultValue')) {\n      controlProp.defaultValue = defaultValue ?? '';\n    }\n\n    const onChange = useCallback(\n      (e: ChangeEvent<HTMLTextAreaElement>) => {\n        if (!hardStop || maxLength === undefined || e.target.value.length <= maxLength) {\n          onChangeProp?.(e);\n          setCharCount(e.target.value.length);\n          resizeTextArea();\n        }\n      },\n      [onChangeProp, resizeTextArea, hardStop, maxLength]\n    );\n\n    const Comp = (\n      <StyledFormControl\n        {...{\n          ref: autoResize ? consolidatedRef : ref,\n          id,\n          required,\n          disabled,\n          status,\n          resizable,\n          maxLength: hardStop ? maxLength : undefined,\n          ...controlProp,\n          ...restProps,\n          onChange,\n          as: StyledTextArea\n        }}\n      />\n    );\n\n    return label || displayCharCount ? (\n      <FormField\n        {...{\n          label,\n          labelHidden,\n          id,\n          info,\n          status,\n          charLimitDisplay:\n            displayCharCount && typeof maxLength === 'number' ? (\n              <Text\n                variant='secondary'\n                aria-live={maxLength >= 0 && maxLength - charCount <= 20 ? 'polite' : 'off'}\n              >\n                {maxLength >= 0 ? t('x_of_y', [charCount || '0', maxLength]) : charCount}\n              </Text>\n            ) : undefined,\n          required,\n          disabled\n        }}\n      >\n        {Comp}\n      </FormField>\n    ) : (\n      Comp\n    );\n  }\n);\n\nexport default TextArea;\n","import { ChangeEvent, useState } from 'react';\nimport { TextArea as TextAreaCosmos } from '@pega/cosmos-react-core';\n\nexport default function InputField(props: any) {\n  const { field } = props;\n  const [inputValue, setInputValue] = useState(field.displayvalue);\n  return (\n    <TextAreaCosmos\n      type='text'\n      label={field.displaylabel}\n      value={inputValue}\n      onChange={(e: ChangeEvent<HTMLTextAreaElement>) => {\n        setInputValue(e.target.value);\n      }}\n    />\n  );\n}\n"],"names":["maxHeight","minHeightProp","element","useRef","_useState","useState","_useState2","_slicedToArray","minHeight","setMinHeight","debouncedAutoResize","debounce","iframe","_element$current$cont","_element$current$cont2","scrollHeightElement","current","HTMLIFrameElement","contentDocument","querySelector","newMinHeight","scrollHeight","style","height","concat","overflowY","Math","min","StyledTextArea","styled","textarea","_ref","resizable","css","_templateObject","_taggedTemplateLiteral","props","theme","components","padding","_templateObject2","defaultProps","defaultThemeProp","forwardRef","ref","uid","useUID","_props$id","id","value","defaultValue","_props$required","required","_props$disabled","disabled","label","labelHidden","info","status","_props$resizable","_props$autoResize","autoResize","maxLength","_props$displayCharCou","displayCharCount","_props$hardStop","hardStop","onChangeProp","onChange","restProps","_objectWithoutProperties","_excluded","t","useI18n","_useAutoResize","useAutoResize","undefined","_useAutoResize2","textAreaRef","resizeTextArea","consolidatedRef","useConsolidatedRef","charCount","setCharCount","controlProp","useEffect","hasProp","length","useCallback","e","target","Comp","_jsx","StyledFormControl","_objectSpread","as","FormField","charLimitDisplay","Text","variant","children","InputField","field","displayvalue","inputValue","setInputValue","TextAreaCosmos","type","displaylabel"],"sourceRoot":""}