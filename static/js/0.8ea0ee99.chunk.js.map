{"version":3,"sources":["../../../../src/components/Tabs/Tab.tsx","../../../../src/components/Tabs/Tabs.tsx","../../../../src/components/Breadcrumbs/Breadcrumbs.tsx","../../../../src/components/Tabs/TabPanel.tsx","../../../src/hooks/useScrollStick.ts"],"names":["color","StyledTab","BareButton","props","tabType","selected","theme","primaryColor","inverted","components","tabs","foreground","base","lightenedColor","spacing","palette","shadow","focus","borderColor","interactive","defaultProps","ref","content","count","type","disabled","restProps","StyledTabs","div","Tabs","badgeVariant","currentTabId","onTabClick","tabRefs","changeTabFocus","event","index","current","length","key","nextIndex","nextTab","prevIndex","prevTab","Flex","container","direction","undefined","item","grow","shrink","as","role","map","tab","i","href","name","id","Count","variant","onClick","el","onKeyDown","e","includes","preventDefault","onKeyUp","Link","tabIndex","StyledBreadcrumbs","oneItemRemaining","Breadcrumbs","path","breadcrumbsEl","setBreadcrumbsEl","numMenuItems","setNumMenuItems","minInlineWidth","breadcrumbRef","debouncedResize","entries","contentRect","width","curr","resizeObserver","ResizeObserver","intersectionObserver","IntersectionObserver","intersectionRatio","rootBounds","style","visibility","root","threshold","lastChild","observe","disconnect","end","gap","alignItems","text","iconOnly","icon","menu","items","slice","reverse","crumb","Comp","primary","visual","restCrumbProps","StyledTabPanel","TabPanel","tabId","children","onBeforeunload","window","scrollTo","Stickers","elements","scrollContainer","offset","this","NaN","getScrollY","setStickers","snapshotItemRects","addHandlers","Array","from","document","querySelectorAll","element","isStuck","top","bottom","height","priorStickHeight","rmHandlers","onScroll","bind","onResize","addEventListener","removeEventListener","forEach","sticker","rect","getBoundingClientRect","clearTimeout","currentScrollY","Number","isNaN","setTimeout","getViewportHeight","getScrollFrameHeight","testForStick","addStick","scrollY","scrollTop","Math","max","documentElement","clientHeight","innerHeight","viewportHeight","sfh","vph","bottomIsInView","testBottomInView","hasHeightChange","requestAnimationFrame","marginTop","removeStick","position","getStickTop","spHeight","options","instance","cleanup"],"mappings":"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","file":"static/js/0.8ea0ee99.chunk.js","sourcesContent":["import { FC, ReactNode, forwardRef, PropsWithoutRef, Ref } from 'react';\nimport styled, { StyledProps, css } from 'styled-components';\nimport { transparentize } from 'polished';\n\nimport { defaultThemeProp } from '../../theme';\nimport { tryCatch } from '../../utils/utils';\nimport { StyledCount } from '../Badges/Count';\nimport { ForwardProps } from '../../types';\nimport BareButton from '../Button/BareButton';\n\nimport { TabsProps } from './Tabs.types';\n\ninterface TabProps {\n  /** Indicates if this Tab is active. */\n  selected: boolean;\n  /**\n   * Indicates if the styling of this Tab is inverted.\n   * @deprecated\n   */\n  inverted: boolean;\n  /** The text to display as the name of the Tab. */\n  content: string;\n  /** A number to associate with the Tab. */\n  count?: ReactNode;\n  /** Determines the direction in which the Tab will render. */\n  type: TabsProps['type'];\n  /** Disables the tab if true */\n  disabled?: boolean;\n}\n\nexport interface StyledTabProps {\n  selected: TabProps['selected'];\n  inverted: TabProps['inverted'];\n  tabType: TabProps['type'];\n}\n\nconst activeStyle = (color: string) => css`\n  ::after {\n    display: block;\n    background-color: ${color};\n  }\n`;\n\nconst getHorizontalStyles = ({ selected, theme, inverted }: StyledProps<StyledTabProps>) => {\n  const primaryColor = inverted\n    ? theme.components.tabs.inverted.foreground\n    : theme.components.tabs.base.foreground;\n  const lightenedColor = tryCatch(() => transparentize(0.3, primaryColor)) ?? '';\n  const { spacing } = theme.base;\n\n  return css`\n    align-items: center;\n    display: flex;\n    flex-direction: row;\n    height: calc(4 * ${spacing});\n    padding: 0 calc(2 * ${spacing});\n    border: none;\n\n    span:first-of-type {\n      color: ${selected ? primaryColor : theme.base.palette['foreground-color']};\n      text-transform: uppercase;\n      display: inline-block;\n\n      ::before {\n        content: attr(data-content);\n        display: block;\n        font-weight: bold;\n        height: 0;\n        overflow: hidden;\n        visibility: hidden;\n      }\n    }\n\n    &:first-child {\n      margin-left: 0;\n    }\n\n    ::after {\n      background: ${selected ? primaryColor : lightenedColor};\n      display: ${selected ? 'block' : 'none'};\n      content: '';\n      position: absolute;\n      height: 0.125rem;\n      bottom: 0;\n      left: 0;\n      right: 0;\n    }\n\n    &:hover&:not(:disabled) {\n      ${activeStyle(lightenedColor)}\n    }\n\n    &:focus {\n      ${activeStyle(lightenedColor)}\n      box-shadow: inset ${theme.base.shadow.focus}\n    }\n\n    ${StyledCount} {\n      margin-inline-start: calc(0.5 * ${spacing});\n    }\n  `;\n};\n\nconst getVerticalStyles = ({ selected, theme }: StyledProps<StyledTabProps>) => {\n  const borderColor = theme.base.palette['border-line'];\n  const primaryColor = theme.base.palette.interactive;\n  const lightenedColor = tryCatch(() => transparentize(0.5, primaryColor)) ?? '';\n  const { spacing } = theme.base;\n\n  return css`\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    border-style: solid;\n    color: ${theme.base.palette['foreground-color']};\n    border-width: 0.0625rem 0;\n    border-color: ${borderColor};\n    height: calc(5.5 * ${spacing});\n    margin-top: -0.0625rem;\n    padding: 0 calc(2 * ${spacing});\n\n    &:first-child {\n      border-top: 0.0625rem solid ${borderColor};\n    }\n\n    ::after {\n      content: '';\n      position: absolute;\n      display: ${selected ? 'block' : 'none'};\n      top: 0;\n      bottom: 0;\n      right: 0;\n      width: 0.25rem;\n      background: ${primaryColor};\n    }\n\n    &:hover&:not(:disabled) {\n      ${activeStyle(lightenedColor)}\n    }\n\n    &:focus {\n      ${activeStyle(primaryColor)}\n      box-shadow: inset 0 0 0 0.0625rem ${primaryColor};\n    }\n  `;\n};\n\nexport const StyledTab = styled(BareButton)<StyledTabProps>`\n  position: relative;\n  background: none;\n  cursor: pointer;\n\n  ${props =>\n    props.tabType === 'horizontal' ? getHorizontalStyles(props) : getVerticalStyles(props)}\n  ${props =>\n    props.selected &&\n    css`\n      font-weight: bold;\n    `}\n  white-space: nowrap;\n\n  & + & {\n    margin-inline-start: 0;\n  }\n\n  &:focus {\n    outline: none;\n  }\n\n  &:disabled {\n    cursor: not-allowed;\n    opacity: ${props => props.theme.base['disabled-opacity']};\n  }\n`;\n\nStyledTab.defaultProps = defaultThemeProp;\n\nconst Tab: FC<TabProps & ForwardProps> = forwardRef(\n  (\n    { selected, inverted, content, count, type, disabled, ...restProps }: PropsWithoutRef<TabProps>,\n    ref: Ref<HTMLButtonElement>\n  ) => {\n    return (\n      <StyledTab\n        ref={ref}\n        selected={selected}\n        inverted={inverted}\n        tabType={type}\n        disabled={disabled}\n        type='button'\n        {...restProps}\n      >\n        <span data-content={content}>{content}</span>\n        {count}\n      </StyledTab>\n    );\n  }\n);\n\nexport default Tab;\n","import {\n  FunctionComponent,\n  MouseEvent,\n  KeyboardEvent,\n  forwardRef,\n  PropsWithoutRef,\n  Ref,\n  useRef\n} from 'react';\nimport styled, { css } from 'styled-components';\n\nimport { defaultThemeProp } from '../../theme';\nimport Flex from '../Flex';\nimport Link from '../Link';\nimport Count from '../Badges/Count';\nimport { ForwardProps } from '../../types';\n\nimport Tab from './Tab';\nimport { TabsProps } from './Tabs.types';\n\ntype TabItem = TabsProps['tabs'][number];\n\nexport const StyledTabs = styled.div<Partial<TabsProps>>(\n  ({ type, theme }) => css`\n    position: relative;\n    overflow: ${type === 'horizontal' ? 'auto' : 'visible'};\n    ${type === 'horizontal' &&\n    css`\n      border-bottom: 0.0625rem solid ${theme.base.palette['border-line']};\n      height: max-content;\n    `}\n  `\n);\n\nStyledTabs.defaultProps = defaultThemeProp;\n\n/**\n * The tabs component will take a list of tab data objects and render out a list of tabs in either vertical or horizontal direction.\n * The tabs component handles which tab is active but will give you a callback function that allows you to make changes when a new tab is activated\n */\nconst Tabs: FunctionComponent<TabsProps & ForwardProps> = forwardRef(\n  (\n    {\n      tabs = [],\n      type = 'horizontal',\n      currentTabId,\n      onTabClick,\n      inverted = false,\n      ...restProps\n    }: PropsWithoutRef<TabsProps>,\n    ref: Ref<HTMLElement>\n  ) => {\n    // Used to keep a reference for every tab in order to focus them with key presses\n    const tabRefs = useRef<(HTMLButtonElement | HTMLAnchorElement)[]>([]);\n\n    // Handles arrow keypresses for changing the focus\n    const changeTabFocus = (event: KeyboardEvent, index: number): void => {\n      if (tabRefs.current?.length) {\n        const { key } = event;\n        if (key === 'ArrowRight' || key === 'ArrowDown') {\n          const nextIndex = index + 1 < tabs.length ? index + 1 : 0;\n          const nextTab = tabRefs.current[nextIndex] as HTMLButtonElement;\n\n          if (!nextTab?.disabled) {\n            nextTab?.focus();\n          } else {\n            changeTabFocus(event, nextIndex);\n          }\n        } else if (key === 'ArrowLeft' || key === 'ArrowUp') {\n          const prevIndex = index === 0 ? tabs.length - 1 : index - 1;\n          const prevTab = tabRefs.current[prevIndex] as HTMLButtonElement;\n          if (!prevTab?.disabled) {\n            prevTab?.focus();\n          } else {\n            changeTabFocus(event, prevIndex);\n          }\n        }\n      }\n    };\n\n    let badgeVariant: 'inverted' | 'default';\n    if (inverted) {\n      badgeVariant = 'inverted';\n    } else {\n      badgeVariant = 'default';\n    }\n\n    return (\n      <Flex\n        {...restProps}\n        container={{\n          direction: type !== 'horizontal' ? 'column' : undefined\n        }}\n        item={{ grow: 1, shrink: 0 }}\n        as={StyledTabs}\n        ref={ref}\n        type={type}\n        role='tablist'\n      >\n        {tabs.map((tab: TabItem, i) => {\n          const { href, name, count, id, disabled } = tab;\n          const selected = id === currentTabId;\n\n          return (\n            <Tab\n              id={id}\n              aria-selected={selected}\n              aria-controls={`${id}-panel`}\n              content={name}\n              count={\n                typeof count === 'number' && (\n                  <Count variant={selected ? 'interactive' : badgeVariant}>{count}</Count>\n                )\n              }\n              href={href}\n              inverted={inverted || false}\n              selected={selected}\n              onClick={(event: MouseEvent<HTMLButtonElement | HTMLAnchorElement>) => {\n                onTabClick?.(id, event);\n              }}\n              role='tab'\n              ref={(el: HTMLButtonElement | HTMLAnchorElement) => {\n                tabRefs.current[i] = el;\n              }}\n              onKeyDown={(e: KeyboardEvent) => {\n                if (['ArrowRight', 'ArrowDown', 'ArrowLeft', 'ArrowUp'].includes(e.key)) {\n                  e.preventDefault();\n                }\n              }}\n              onKeyUp={(e: KeyboardEvent<any>) => {\n                changeTabFocus(e, i);\n              }}\n              key={id}\n              as={href ? Link : undefined}\n              tabIndex={selected ? undefined : -1}\n              aria-label={name}\n              type={type}\n              disabled={disabled}\n            />\n          );\n        })}\n      </Flex>\n    );\n  }\n);\n\nexport default Tabs;\n","import {\n  forwardRef,\n  Fragment,\n  FunctionComponent,\n  PropsWithoutRef,\n  Ref,\n  useEffect,\n  useRef,\n  useState\n} from 'react';\nimport styled, { css } from 'styled-components';\n\nimport { useElement, useConsolidatedRef, useDirection } from '../../hooks';\nimport { defaultThemeProp } from '../../theme';\nimport { BaseProps, ForwardProps } from '../../types';\nimport { debounce } from '../../utils';\nimport Button from '../Button';\nimport Flex from '../Flex';\nimport Link from '../Link';\nimport Icon, { StyledIcon, registerIcon } from '../Icon';\nimport * as caretLeftIcon from '../Icon/icons/caret-left.icon';\nimport * as caretRightIcon from '../Icon/icons/caret-right.icon';\nimport MenuButton from '../MenuButton';\nimport Text from '../Text';\nimport { MenuItemProps } from '../Menu';\n\nregisterIcon(caretLeftIcon, caretRightIcon);\n\nexport interface BreadcrumbsProps extends BaseProps {\n  /** A set of actions representing the chronological hierarchy of pages or locations leading to the current view. */\n  path: MenuItemProps[];\n  /** Ref forwarded to the wrapping element. */\n  ref?: Ref<HTMLDivElement>;\n}\n\nexport const StyledBreadcrumbs = styled.div<{ oneItemRemaining: boolean }>(\n  ({ oneItemRemaining }) => css`\n    white-space: nowrap;\n    overflow: visible;\n    visibility: hidden;\n\n    ${StyledIcon} {\n      width: 1em;\n      height: 1em;\n      flex-shrink: 0;\n    }\n\n    ${oneItemRemaining &&\n    css`\n      & > :last-child {\n        text-overflow: ellipsis;\n        overflow: hidden;\n      }\n    `}\n  `\n);\n\nStyledBreadcrumbs.defaultProps = defaultThemeProp;\n\nconst Breadcrumbs: FunctionComponent<BreadcrumbsProps & ForwardProps> = forwardRef(\n  ({ path, ...restProps }: PropsWithoutRef<BreadcrumbsProps>, ref: BreadcrumbsProps['ref']) => {\n    const [breadcrumbsEl, setBreadcrumbsEl] = useElement<HTMLDivElement>();\n    const [numMenuItems, setNumMenuItems] = useState(0);\n    const minInlineWidth = useRef(0);\n\n    const breadcrumbRef = useConsolidatedRef(setBreadcrumbsEl, ref);\n\n    const debouncedResize = debounce((entries: ResizeObserverEntry[]) => {\n      if (entries[0].contentRect.width > minInlineWidth.current) {\n        setNumMenuItems(curr => {\n          if (curr === 0) return curr;\n          return curr - 1;\n        });\n      }\n    }, 100);\n\n    const resizeObserver = new ResizeObserver(debouncedResize);\n\n    const intersectionObserver = new IntersectionObserver(\n      entries => {\n        if (entries[0].intersectionRatio < 1 && numMenuItems < path.length - 1) {\n          if (entries[0].rootBounds) minInlineWidth.current = entries[0].rootBounds.width + 1;\n          setNumMenuItems(curr => {\n            if (curr === path.length - 1) return curr;\n            return curr + 1;\n          });\n        } else if (breadcrumbsEl) breadcrumbsEl.style.visibility = 'visible';\n      },\n      { root: breadcrumbsEl, threshold: 1 }\n    );\n\n    useEffect(() => {\n      if (breadcrumbsEl && breadcrumbsEl.lastChild) {\n        intersectionObserver.observe(breadcrumbsEl.lastChild as Element);\n        resizeObserver.observe(breadcrumbsEl);\n\n        return () => {\n          intersectionObserver.disconnect();\n          resizeObserver.disconnect();\n        };\n      }\n    }, [breadcrumbsEl, numMenuItems]);\n\n    const { end } = useDirection();\n\n    return (\n      <Flex\n        {...restProps}\n        container={{ gap: 1, alignItems: 'center' }}\n        as={StyledBreadcrumbs}\n        oneItemRemaining={numMenuItems === path.length - 1}\n        ref={breadcrumbRef}\n      >\n        {numMenuItems > 0 && (\n          <>\n            <MenuButton\n              text='Links'\n              iconOnly\n              variant='link'\n              icon='folder-hierarchy-solid'\n              menu={{ items: path.slice(0, numMenuItems).reverse() }}\n            />\n            <Icon name={`caret-${end}`} />\n          </>\n        )}\n        {path.slice(numMenuItems).map((crumb, index) => {\n          const { id, primary, visual, ...restCrumbProps } = crumb;\n          let Comp;\n          if (crumb.href)\n            Comp = (\n              <Link key={id} href={crumb.href} {...restCrumbProps}>\n                {visual} {primary}\n              </Link>\n            );\n          else if (crumb.onClick)\n            Comp = (\n              <Button key={id} variant='link' {...restCrumbProps}>\n                {visual} {primary}\n              </Button>\n            );\n          else\n            Comp = (\n              <Text key={id} {...restCrumbProps}>\n                {visual} {primary}\n              </Text>\n            );\n\n          if (index === path.slice(numMenuItems).length - 1) return Comp;\n\n          return (\n            <Fragment key={id}>\n              {Comp}\n              <Icon name={`caret-${end}`} />\n            </Fragment>\n          );\n        })}\n      </Flex>\n    );\n  }\n);\n\nexport default Breadcrumbs;\n","import { forwardRef, FunctionComponent, ReactNode, Ref, PropsWithoutRef } from 'react';\nimport styled, { css } from 'styled-components';\n\nimport { ForwardProps } from '../../types';\n\ninterface TabPanelProps {\n  /** The id of the Tab that the tab panel is related to. */\n  tabId: string;\n  /**\n   * The current selected value of the tabs. Controls the visibility of the tab panel.\n   * The tabsValue must match the tabId in order for the TabPanel to show itself.\n   * */\n  currentTabId?: string;\n  /** Content of the tab panel. */\n  children: ReactNode;\n  /** Ref for the wrapping element. */\n  ref?: Ref<HTMLDivElement>;\n}\n\nconst defaultProps: Partial<TabPanelProps> = {\n  tabId: ''\n};\n\nexport const StyledTabPanel = styled.div<{ current: boolean }>(({ current }) => {\n  return css`\n    :focus {\n      outline: none;\n    }\n\n    ${!current &&\n    css`\n      display: none;\n    `}\n  `;\n});\n\nconst TabPanel: FunctionComponent<TabPanelProps & ForwardProps> = forwardRef(\n  (\n    { tabId, currentTabId, children, ...restProps }: PropsWithoutRef<TabPanelProps>,\n    ref: TabPanelProps['ref']\n  ) => {\n    const getTabIndex = () => {\n      if (currentTabId && tabId) {\n        return currentTabId === tabId ? 0 : undefined;\n      }\n      return 0;\n    };\n    return (\n      <StyledTabPanel\n        {...restProps}\n        current={currentTabId && tabId ? currentTabId === tabId : true}\n        role='tabpanel'\n        tabIndex={getTabIndex()}\n        aria-labelledby={`${tabId}`}\n        id={`${tabId}-panel`}\n        ref={ref}\n      >\n        {children}\n      </StyledTabPanel>\n    );\n  }\n);\n\nTabPanel.defaultProps = defaultProps;\n\nexport default TabPanel;\n","import { useRef, useLayoutEffect } from 'react';\n\nexport interface ScrollStickOptions {\n  elements: string | HTMLElement[];\n  scrollContainer?: Stickers['scrollContainer'];\n  offset?: number;\n}\n\ninterface Sticker {\n  element: HTMLElement;\n  top: number;\n  bottom: number;\n  height: number;\n  isStuck: boolean;\n  priorStickHeight: number;\n}\n\ntype ElementsOption = string | HTMLElement[];\n\nconst onBeforeunload = () => {\n  window.scrollTo(0, 0);\n};\n\nclass Stickers {\n  scrollContainer: HTMLElement | Window;\n  offset: number;\n  #scrollDebounce: number;\n  #resizeDebounce: number;\n  #isWindowScroll: boolean;\n  #scrollIntervalStart: number;\n  #scrollIntervalChange: number;\n  #scrollDirection: number;\n  #priorScrollY: number;\n  #resizeTimeout: number;\n  #scrollEndTimeout: number;\n  #isScrolling: boolean;\n  #vpHeightSnapshot: number;\n  #sfHeightSnapshot: number;\n  #stickers: Sticker[];\n  #scrollHandler: () => void;\n  #resizeHandler: () => void;\n\n  constructor({ elements, scrollContainer = window, offset = 0 }: ScrollStickOptions) {\n    this.scrollContainer = scrollContainer;\n    this.offset = offset;\n\n    this.#scrollDebounce = 100;\n    this.#resizeDebounce = 300;\n    this.#resizeTimeout = NaN;\n    this.#scrollEndTimeout = NaN;\n    this.#priorScrollY = NaN;\n    this.#isScrolling = false;\n    this.#vpHeightSnapshot = NaN;\n    this.#sfHeightSnapshot = NaN;\n    this.#scrollHandler = () => {};\n    this.#resizeHandler = () => {};\n\n    this.#isWindowScroll = this.scrollContainer === window;\n\n    // Only gets reset after scroll stop timeout fires\n    this.#scrollIntervalStart = this.getScrollY();\n\n    // Used to determine scroll change within debounced scroll handler\n    this.#scrollIntervalChange = 0;\n\n    // Used to determine scroll direction by +1(page down) -1(page up)\n    this.#scrollDirection = 0;\n\n    this.#stickers = this.setStickers(elements);\n    this.snapshotItemRects();\n    this.addHandlers();\n  }\n\n  setStickers(elements: ElementsOption) {\n    this.#stickers = (\n      typeof elements === 'string'\n        ? Array.from(document.querySelectorAll<HTMLElement>(elements))\n        : elements\n    ).map(element => ({\n      element,\n      isStuck: false,\n      top: NaN,\n      bottom: NaN,\n      height: NaN,\n      priorStickHeight: NaN\n    }));\n\n    return this.#stickers;\n  }\n\n  addHandlers() {\n    this.rmHandlers();\n    this.#scrollHandler = this.onScroll.bind(this);\n    this.#resizeHandler = this.onResize.bind(this);\n    this.scrollContainer.addEventListener('scroll', this.#scrollHandler);\n    window.addEventListener('resize', this.#resizeHandler);\n    // Not sure we need this. Maybe when DOM was persisted...\n    window.addEventListener('beforeunload', onBeforeunload);\n  }\n\n  rmHandlers() {\n    this.scrollContainer.removeEventListener('scroll', this.#scrollHandler);\n    window.removeEventListener('resize', this.#resizeHandler);\n    window.removeEventListener('beforeunload', onBeforeunload);\n  }\n\n  snapshotItemRects() {\n    this.#stickers.forEach(sticker => {\n      const rect = sticker.element.getBoundingClientRect();\n      sticker.top = rect.top;\n      sticker.bottom = rect.bottom;\n      sticker.height = rect.height;\n    });\n  }\n\n  onScroll() {\n    clearTimeout(this.#scrollEndTimeout);\n\n    const currentScrollY = this.getScrollY();\n\n    this.#priorScrollY = !Number.isNaN(this.#priorScrollY)\n      ? this.#priorScrollY\n      : this.#scrollIntervalStart;\n\n    // Diff between priorScrollY and new currentScrollY to determine direction\n    this.#scrollDirection = currentScrollY - this.#priorScrollY > 0 ? 1 : -1;\n\n    // How much scroll changed + or - within the debounce interval\n    this.#scrollIntervalChange = currentScrollY - this.#scrollIntervalStart;\n\n    // Update old to new for next scroll event\n    this.#priorScrollY = currentScrollY;\n\n    // When scrolling has stopped\n    this.#scrollEndTimeout = window.setTimeout(() => {\n      // Reset for next scroll starting point\n      this.#scrollIntervalStart = this.#priorScrollY;\n\n      // Reset until next scroll\n      this.#vpHeightSnapshot = NaN;\n      this.#sfHeightSnapshot = NaN;\n\n      this.#isScrolling = false;\n    }, this.#scrollDebounce);\n\n    // Additional scroll calls always have to test for stick state change\n    if (this.#isScrolling) {\n      this.testForStick();\n      return;\n    }\n\n    // Only reaches here on first call and we note as in a scrolling state\n    this.#isScrolling = true;\n\n    // grab the current rect points for stickers to test against while scrolling\n    this.snapshotItemRects();\n\n    /**\n     * Get once and cache until scroll settles\n     * Unlikely to change and avoids additional reflows on scroll\n     */\n    this.#vpHeightSnapshot = this.getViewportHeight();\n    this.#sfHeightSnapshot = this.getScrollFrameHeight();\n\n    this.testForStick();\n  }\n\n  onResize() {\n    clearTimeout(this.#resizeTimeout);\n    this.#resizeTimeout = window.setTimeout(() => {\n      this.snapshotItemRects();\n      this.#stickers.forEach(sticker => {\n        if (sticker.isStuck) this.addStick(sticker);\n      });\n    }, this.#resizeDebounce);\n  }\n\n  getScrollY() {\n    return this.#isWindowScroll\n      ? (this.scrollContainer as Window).scrollY\n      : (this.scrollContainer as HTMLElement).scrollTop;\n  }\n\n  getViewportHeight() {\n    // If we have a height snapshot use it since this has likely been called on scroll\n    if (!Number.isNaN(this.#vpHeightSnapshot)) {\n      return this.#vpHeightSnapshot;\n    }\n\n    return Math.max(document.documentElement.clientHeight, window.innerHeight || 0);\n  }\n\n  getScrollFrameHeight() {\n    // If we have a height snapshot use it since this has likely been called on scroll\n    if (!Number.isNaN(this.#sfHeightSnapshot)) {\n      return this.#sfHeightSnapshot;\n    }\n\n    const viewportHeight = this.getViewportHeight();\n    let sfh = viewportHeight;\n\n    if (!this.#isWindowScroll) {\n      sfh = viewportHeight - (this.scrollContainer as HTMLElement).getBoundingClientRect().top;\n    }\n\n    return sfh;\n  }\n\n  testBottomInView(sticker: Sticker) {\n    const vph = this.getViewportHeight();\n    const sfh = this.getScrollFrameHeight();\n    const sic = this.#scrollIntervalChange;\n\n    return sfh + sic + (vph - sfh) >= sticker.bottom + this.offset;\n  }\n\n  testForStick() {\n    // Don't do anything if scrolling up\n    if (this.#scrollDirection === -1) return;\n\n    this.#stickers.forEach(sticker => {\n      const bottomIsInView = this.testBottomInView(sticker);\n      const hasHeightChange =\n        !Number.isNaN(sticker.priorStickHeight) && sticker.height !== sticker.priorStickHeight;\n\n      if (bottomIsInView) {\n        if (!sticker.isStuck || hasHeightChange) {\n          window.requestAnimationFrame(() => this.addStick(sticker));\n        }\n      } else if (sticker.isStuck && hasHeightChange) {\n        const marginTop = this.getScrollY() + sticker.top - this.offset;\n\n        window.requestAnimationFrame(() => {\n          this.removeStick(sticker);\n          sticker.element.style.marginTop = `${marginTop}px`;\n        });\n      }\n    });\n\n    return this;\n  }\n\n  addStick(sticker: Sticker) {\n    sticker.element.style.position = 'sticky';\n    sticker.element.style.marginTop = '';\n    sticker.element.style.top = `${this.getStickTop(sticker)}px`;\n    sticker.priorStickHeight = sticker.height;\n    sticker.isStuck = true;\n    return this;\n  }\n\n  removeStick(sticker: Sticker) {\n    sticker.element.style.position = '';\n    sticker.element.style.marginTop = '';\n    sticker.element.style.top = '';\n    sticker.isStuck = false;\n    return this;\n  }\n\n  getStickTop(sticker: Sticker) {\n    const spHeight = this.getScrollFrameHeight();\n    let offset = this.offset;\n\n    if (sticker.height + this.offset > spHeight) {\n      offset = spHeight - sticker.height - offset;\n    }\n\n    return offset;\n  }\n\n  cleanup() {\n    this.rmHandlers();\n    this.#stickers.forEach(this.removeStick);\n  }\n}\n\n/**\n * @example useScrollStick({ elements: [myColumnElements] | '.my-columns', offset: 20 });\n * @param options An object to set the sticky elements, the scroll container and an stuck offset in pixels.\n * @returns void.\n */\nconst useScrollStick = (options?: ScrollStickOptions): void => {\n  const instance = useRef<Stickers>();\n\n  useLayoutEffect(() => {\n    if (options?.elements) {\n      instance.current = new Stickers(options);\n    }\n\n    return () => {\n      instance.current?.cleanup();\n      instance.current = undefined;\n    };\n  }, [options]);\n};\n\nexport default useScrollStick;\n"],"sourceRoot":""}